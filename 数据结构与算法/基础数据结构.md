# 数据结构
[算法 - 排序 | CS-Notes (cyc2018.xyz)](http://www.cyc2018.xyz/%E7%AE%97%E6%B3%95/%E5%9F%BA%E7%A1%80/%E7%AE%97%E6%B3%95%20-%20%E6%8E%92%E5%BA%8F.html)

## 排序算法的比较

|       算法       | 稳定性 |          时间复杂度          | 空间复杂度 |           备注           |
| :--------------: | :----: | :--------------------------: | :--------: | :----------------------: |
|     选择排序     |   ×    |            $N^2$             |     1      |                          |
|     冒泡排序     |   √    |            $N^2$             |     1      |                          |
|     插入排序     |   √    |          N ~ $N^2$           |     1      | 时间复杂度和初始顺序有关 |
|     希尔排序     |   ×    | N 的若干倍乘于递增序列的长度 |     1      |      改进版插入排序      |
|     快速排序     |   ×    |            NlogN             |    logN    |                          |
| 三向切分快速排序 |   ×    |          N ~ NlogN           |    logN    |   适用于有大量重复主键   |
|     归并排序     |   √    |            NlogN             |     N      |                          |
|      堆排序      |   ×    |            NlogN             |     1      |    无法利用局部性原理    |

快速排序是最快的通用排序算法，它的内循环的指令很少，而且它还能利用缓存，因为它总是顺序地访问数据。它的运行时间近似为 ~cNlogN，这里的 c 比其它线性对数级别的排序算法都要小。
使用三向切分快速排序，实际应用中可能出现的某些分布的输入能够达到线性级别，而其它排序算法仍然需要线性对数时间。
Java 主要排序方法为 java.util.Arrays.sort()，对于原始数据类型使用三向切分的快速排序，对于引用类型使用归并排序。



# 堆数据结构

[「图解数据结构」堆 (qq.com)](https://mp.weixin.qq.com/s/C7ZkHXuOeLI6b7CWQSX1Lw)

**什么是堆？**
堆是一种满足特殊条件的树。
这种树的任意一个节点的值都大于等于（或小于等于）子树中所有节点的值。

通常我们使用完全二叉树（叶子节点只出现在最下层或者次下层，且最下层的叶子节点都位于左侧）的形式来表示堆。

![[Pasted image 20210530212742.png]]
1是大顶堆；2是小顶堆；3不是堆。

**什么时候使用堆？**
关心数据的最大值和最小值；需要插入或删除数据。

和有序数组进行对比：
初始化有序数组时间复杂度O(nlog(n))；查找最大值和最小值时间复杂度为O(1);更新、修改和删除时间复杂度为O(n).

堆的优势：更新数据效率高。堆的初始化时间复杂度为 `O(nlog(n))`，堆可以做到`O(1)`时间复杂度取出最大值或者最小值，`O(log(n))`时间复杂度更新、插入或者删除数据。

**堆是怎么分类的？**
大顶堆：堆中的每一个节点的值都大于等于子树中所有节点的值
小顶堆：堆中的每一个节点的值都小于等于子树中所有节点的值


**堆是怎么存储的？**
由于完全二叉树的优秀性质，使用数组存储堆方便索引，也节省空间。
存储方式如下：
![[Pasted image 20210530220441.png]]
位置 k 的节点的父节点位置为 k/2，而它的两个子节点的位置分别为 2k 和 2k+1。这里不使用数组索引为 0 的位置，是为了更清晰地描述节点的位置关系。

**堆的操作**

- 插入元素
步骤：
1、将要插入的元素放到最后
2、从底向上，如果父节点比该元素小，则父节点和该节点交换值。直到无法交换。

- 删除堆顶元素
以大顶堆为例（小顶堆同理）：
当删除了堆顶元素，最大值的位置发生空缺，需要进行结构调整从而保持堆的结构。这一过程称为堆化。
堆化分类:

- 自底向上（填充值从底向上，能者居上）
比较根节点的左右子节点，大的填充；不断循环，直到堆到最底部。（但是可能产生气泡现象）

- **自顶向下（填充值从顶向下走，石沉大海）**
将最后一个元素移动到堆顶，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。


**堆排序**
堆排序的目的：是获取一个有序的从小到大的列表、数组或者序列
本质：大顶堆堆顶为最大的元素，取出后，堆尾元素放到堆顶，进行下沉操作，从而又获得一个堆顶，即次大的元素。如此往复，即可获得一个有序的序列。但要注意，如果是在原始堆的存储上修改，会把堆的结构破坏；但不在原始堆上进行操作，则需要额外的空间来存储。

堆排序的过程分为两步：
>-   第一步是建堆，将一个无序的数组建立为一个堆
>-   第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。

建堆：
首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为 n，那么我们需要对 n/2 到 1 的节点进行自顶向下（沉底）堆化。
将初始的无序数组抽象为一棵树，选取非叶节点，顺序是从后往前堆化，直至到达根节点。

排序：
- 在建好堆的基础上，将堆尾的元素与堆顶的元素交换（该最大元素已经被排除堆外，不再参与堆的操作），即取出最大的元素，进行下沉操作，从而获得新的堆顶。












