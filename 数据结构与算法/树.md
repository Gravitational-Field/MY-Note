
# 树的相关概念
## 二叉树：
> 二叉树（Binary Tree）是指每个节点最多只有两个分支的树结构，即不存在分支大于 2 的节点。

![[Pasted image 20210511154547.png]]


## 二叉搜索树（二叉查找树）
> 二叉搜索树是空树或者满足：
> 1、若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；
2、若任意节点的右子树不为空，则右子树上所有节点的值均大于或等于它的根节点的值；
3、任意节点的左、右子树分别为二叉查找树。
![[Pasted image 20210511154625.png]]

## 平衡树：
树中每个节点的平衡因子小于等于1
![[Pasted image 20210511155034.png]]
![[Pasted image 20210511155041.png]]

## 红黑树
> 是一种自平衡的二叉查找树，二叉查找树均匀分布，从而减少二叉搜索树的深度。能够有效减少二叉树的深度，从而提高查询的效率。

**特性：**
-  节点是红色或黑色；
-  根节点是黑色；
-  所有叶子都是黑色的空节点（NIL 节点）；
- 每个红色系欸但必须有两个黑色的子节点，也就是说从每个叶子到根的所有路径上，不能有两个连续的红色节点；
- 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑色节点。
示意图如下：
![[Pasted image 20210511160456.png]]

**优势：**
红黑树的优势在于它是一个平衡二叉查找树，对于普通的二叉查找树（非平衡二叉查找树）在极端情况下可能会退化为链表的结构，再进行元素的添加、删除以及查询时，它的时间复杂度就会退化为 O(n)；如果使用红黑树的话，它就会将以上数据转化为平衡二叉查找树，这样就可以更加高效的添加、删除以及查询数据。
> 红黑树的高度近似 log2n，它的添加、删除以及查询数据的时间复杂度为 O(logn)。




### 红黑树是如何保证自平衡的？
红黑树能够实现自平衡和保持红黑树特征的主要手段是：**变色、左旋和右旋**。
- 左旋
> **左旋**指的是围绕某个节点向左旋转，也就是逆时针旋转某个节点，使得父节点被自己的右子节点所替代。
如下图所示：
![[Pasted image 20210511162102.png]]

在 TreeMap 源码中左旋的实现源码如下：
```java
// 源码基于 JDK 1.8
private void rotateLeft(Entry<K,V> p) {
    if (p != null) {
        // 右子节点
        Entry<K,V> r = p.right; 
        // p 节点的右子节点为 r 的左子节点
        p.right = r.left;
        // r 左子节点如果非空，r 左子节点的父节点设置为 p 节点
        if (r.left != null) 
            r.left.parent = p; 
        r.parent = p.parent; // r 父节点等于 p 父节点
        // p 父节点如果为空，那么讲根节点设置为 r 节点
        if (p.parent == null)
            root = r;
        // p 父节点的左子节点如果等于 p 节点，那么 p 父节点的左子节点设置 r 节点
        else if (p.parent.left == p)
            p.parent.left = r;
        else
            p.parent.right = r;
        r.left = p; 
        p.parent = r;
    }
}
```

> 左旋代码说明：在刚开始时，p 为父节点，r 为子节点，在左旋操作后，r 节点代替 p 节点的位置，p 节点成为 r 节点的左孩子，而 r 节点的左孩子成为 p 节点的右孩子。

- 右旋
> **右旋**指的是围绕某个节点向右旋转，也就是顺时针旋转某个节点，此时父节点会被自己的左子节点取代

如下图所示：
![[Pasted image 20210511162714.png]]
在 TreeMap 源码中右旋的实现源码如下：

```
private void rotateRight(Entry<K,V> p) {
    if (p != null) {
        Entry<K,V> l = p.left;
        // p 节点的左子节点为 l 的右子节点
        p.left = l.right;
        // l 节点的右子节点非空时，设置 l 的右子节点的父节点为 p
        if (l.right != null) l.right.parent = p;
        l.parent = p.parent;
        // p 节点的父节点为空时，根节点设置成 l 节点
        if (p.parent == null)
            root = l;
        // p 节点的父节点的右子节点等于 p 节点时，p 的父节点的右子节点设置为 l
        else if (p.parent.right == p)
            p.parent.right = l;
        else p.parent.left = l;
        l.right = p;
        p.parent = l;
    }
}
```
> 右旋代码说明：在刚开始时，p 为父节点 l 为子节点，在右旋操作后，l 节点代替 p 节点，p 节点成为 l 节点的右孩子，l 节点的右孩子成为 p 节点的左孩子。

对于红黑树来说，如果当前节点的左、右子节点均为红色时，因为需要满足红黑树定义的第四条特征，所以需要执行变色操作，如下图所示：

![[Pasted image 20210511162840.png]]


## B树

## B+树