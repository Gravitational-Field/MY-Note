
### 设计模式

#### 模板模式
![[模板模式.png]]

#### 单例模式

#### 装饰者模式

#### 代理模式

#### 简单工厂模式

#### 工厂模式


#### 适配器模式
[适配器模式及典型应用\_小旋锋 的博客-CSDN博客](https://blog.csdn.net/wwwdc1012/article/details/82780560)


### Spring 框架中用到了哪些设计模式？
[JavaGuide (设计模式篇)](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns?id=%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f)

 -  **单例设计模式** : Spring 中的 Bean 默认都是单例的。
单例设计模式，容器中只提供一个实例对象。

-   **工厂设计模式** : Spring使用工厂模式通过 `BeanFactory`、`ApplicationContext` 创建 bean 对象。
	BeanFactory是bean在使用时才注入，即为延后注入；而Application会在容器一开启就进行注入。ApplicationContext是BeanFactory的继承类，并在BeanFactory上做了一些扩展。
	ApplicationContext的三个实现类：ClassPathXmlApplicaiton、FileSystemXmlApplicationContext、XmlWebApplication；从指定位置加载上下文信息

-   **代理设计模式** : Spring AOP 功能的实现。
面向切面编程能够将与业务无关但与业务共同协同的逻辑封装起来，如日志处理、事务处理、权限控制等功能。从而实现各个模块的解耦，有利于业务的可扩展性和和维护性。
AOP又称作面向切面编程，切面是一个过程，就是将增强或者说通知 应用在切入点的过程。AOP通过实现代理模式，生成类的代理，从而对原先的方法，也就是切入点上进行扩展。常用的代理方式有JDK动态代理和Cglib动态代理，JDK动态代理用于实现了接口的类上，而Cglib动态代理常用于存在继承关系的类上。

Java还有一个更加全面的切面编程框架AspectJ，相比Spring AOP来说，SpringAOP是运行时增强，而AspectJ是一个编译时增强；AspectJ是Java中最完整的AOP框架，其功能也比SpringAOP更加强大，但SpringAOP相对来说用起来更简单。
平常时两者用起来性能差异不大，但切面太多选择AspectJ会快很多。

-   **模板方法模式** : Spring 中 `jdbcTemplate`、`hibernateTemplate` 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。
定义一个操作的骨架，某些方法延迟到子类中去重写，从而不改变一个类的结构，即可重新定义某些步骤。通常通过抽象类及其子类的方式进行实现。Spring中并没有使用这种方式，而是使用callback和模板方法的方式。

-   **观察者模式:** Spring 事件驱动模型就是观察者模式很经典的一个应用。
观察者模式解决的问题是：当一个对象发生改变时，这个对象所依赖的对象也会做出反应。Spring中比如我们需要在添加商品的时候，需要重新更新商品索引。
Spring时间驱动模型中的三个角色：
1、事件角色
Spring中的事件角色：
EventObject<——ApplicationEvent<——ApplicationContextEvent
其实现类：启动后出发事件、停止后触发事件、初始化或者刷新后触发、关闭后触发。
![[Pasted image 20210530195247.png]]

2、事件监听者角色
ApplicationListener 事件监听者接口，内部定义的`onApplicationEvent（）`方法来处理`ApplicationEvent`


3、事件发布者角色
ApplicationEventPublisher 为事件发布者接口，其中的publishEvent（）方法通过广播的方式来将时间广播出去。

Spring事件处理流程：
事件发布者接收到事件后，监听者Lintener调用相应处理监听的方法。

-   **适配器模式** :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配`Controller`。
适配器模式主要解决一个问题，就是有一个target接口，有一个targetee被调用者类，如何能够在target的方法中使用targetee中的方法，即如何能够关联两者，通过适配器，将两者进行关联。创建的Adapter类实现target接口，并继承被调用者类，即可在适配器实现的target的相应方法中来调用被调用者中的方法。
1、Spring AOP中的 前置通知、后置通知、目标返回通知等，需要通过AdviceAdapter将不同的通知适配到不同的拦截器接口所实现的对象。
2、SpringMVC中，HandlerAdapter的作用是将不同的HandlerMapping映射来的handler与相应的Controller关联起来。


-   **装饰者设计模式** : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要，会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
装饰者模式可以动态的给对象添加一些额外的属性和行为。这也符合面向对象设计的开闭原则，对扩展开发，对修改关闭。在不改变原代码的功能的基础上，设计一个额外的类套在原有代码外面。
JDK中比较典型的是InputStream家族，InputStream类下有FileInputStream、BufferedInputStream扩展InputStream的功能。
Spring 中有时需要动态的切换不同的数据源，通过动态的给一个对象添加一些额外的职责。







